##Контрольная работа по алгоритмическим структурам сортировки и поиска на языках: C++, Python, Java. (Власова Дарья, УИБО-10-24)
##1. Сортировка выбором ( Selection sort)

###Определение:
Алгоритм разделяет массив на отсортированную и неотсортированную части. На каждом шаге находится минимальный элемент в неотсортированной части и перемещается в конец отсортированной части.

###Анализ:
- Внешний цикл выполняется n-1 раз
- Внутренний цикл выполняется n-1, n-2, ..., 1 раз
- Общее количество сравнений: n×(n-1)/2

###Временная сложность:

Лучший случай: O(n²)
###Причина
O(n²): Два вложенных цикла, каждый из которых зависит от n. Количество сравнений всегда равно n×(n-1)/2 независимо от входных данных.

###Ключевые переменные:
- i - индекс текущей позиции в отсортированной части
- min_index - индекс минимального элемента в неотсортированной части
- j - индекс для поиска минимального элемента

##2. Сортировка обменом (Пузырьковая сортировка)

###Определение:
Алгоритм многократно проходит через массив, сравнивая соседние элементы и меняя их местами при неправильном порядке.

###Анализ:

- Внешний цикл выполняется n-1 раз
- Внутренний цикл в худшем случае выполняется n-1, n-2, ..., 1 раз
- Общее количество сравнений: n×(n-1)/2

###Временная сложность:

Лучший случай: O(n)
###Причина O(n²): Два вложенных цикла, где внутренний цикл в среднем выполняется ~n/2 раз для каждого прохода внешнего цикла.

###Ключевые переменные:

- swapped - флаг, указывающий были ли обмены на текущем проходе
- i - счетчик проходов
- j - индекс для сравнения соседних элементов

##3. Сортировка вставками

###Определение:
Алгоритм строит отсортированную последовательность, поочередно вставляя элементы в правильную позицию.

###Анализ:

- Внешний цикл выполняется n-1 раз
- Внутренний цикл в худшем случае выполняется i раз для i-го элемента
- Общее количество сравнений: до n×(n-1)/2

###Временная сложность:

Лучший случай: O(n)
###Причина O(n²): В худшем случае каждый новый элемент приходится сравнивать со всеми элементами отсортированной части.

###Ключевые переменные:

- key - текущий вставляемый элемент
- i - индекс текущего элемента
- j - индекс для поиска позиции вставки

##4. Сортировка слиянием

###Определение:
Алгоритм "разделяй и властвуй", который рекурсивно делит массив пополам, сортирует каждую половину и объединяет их.

###Анализ:

- Массив делится пополам log n раз
- На каждом уровне объединение требует O(n) операций
- Всего уровней: O(log n)

###Временная сложность:

Лучший случай: O(n log n)
###Причина O(n log n): Рекурсивное деление на log n уровней, на каждом уровне выполняется O(n) операций слияния.

###Ключевые функции и переменные:

- merge() - функция слияния двух отсортированных массивов
- left, right - временные массивы для хранения половин
- i, j, k - индексы для слияния массивов

##5. Сортировка Шелла

###Определение:
Улучшенная версия сортировки вставками, которая сравнивает элементы, находящиеся на определенном расстоянии друг от друга.

###Анализ:

- Использует последовательность промежутков
- Эффективность зависит от выбора последовательности промежутков
- Уменьшает количество инверсий

###Временная сложность:

Лучший случай: O(n log n)
###Причина O(n²): Для плохих последовательностей промежутков может вырождаться в квадратичную сложность.

###Ключевые переменные:

- gap - текущий промежуток между сравниваемыми элементами
- i, j - индексы для сравнения элементов на расстоянии gap

##6. Быстрая сортировка

###Определение:
Алгоритм "разделяй и властвуй", который выбирает опорный элемент и разделяет массив на элементы меньше и больше опорного.

###Анализ:

- В среднем случае: O(log n) уровней рекурсии
- На каждом уровне: O(n) операций разделения
- Эффективность зависит от выбора опорного элемента

###Временная сложность:

Лучший случай: O(n log n)
###Причина O(n log n): В среднем случае массив делится пополам на каждом уровне рекурсии, создавая log n уровней с O(n) операциями на каждом.

###Ключевые функции и переменные:

- pivot - опорный элемент
- partition() - функция разделения массива
- low, high - границы текущего подмассива

##7. Пирамидальная сортировка

###Определение:
Использует структуру данных "куча" (heap) для сортировки элементов.

###Анализ:

- Построение кучи: O(n)
- Извлечение каждого элемента из кучи: O(log n)
- Всего n извлечений

###Временная сложность:

Лучший случай: O(n log n)
###Причина O(n log n): n операций извлечения из кучи, каждая стоимостью O(log n).

###Ключевые функции и переменные:

- heapify() - функция построения кучи
- heap_size - размер текущей кучи
- root, left, right - индексы в структуре кучи

##8. Последовательный поиск

###Определение:
Поиск элемента путем последовательного просмотра всех элементов массива.

###Анализ:

- В худшем случае просматриваются все n элементов
- В среднем случае просматривается n/2 элементов

###Временная сложность:

Лучший случай: O(1)
###Причина O(n): В худшем случае требуется проверить каждый элемент массива.

###Ключевые переменные:

- target - искомый элемент
- i - индекс текущего проверяемого элемента

##9. Бинарный поиск

###Определение:
Поиск в отсортированном массиве путем деления области поиска пополам на каждом шаге.

###Анализ:

- На каждом шаге область поиска уменьшается вдвое
- Максимальное количество шагов: log₂n

###Временная сложность:

Лучший случай: O(1)
###Причина O(log n): На каждом шаге размер области поиска уменьшается в 2 раза.

###Ключевые переменные:

- low, high - границы области поиска
- mid - средний индекс текущей области

##10. Интерполирующий поиск

###Определение:
Улучшенный бинарный поиск, который выбирает точку разделения на основе значения искомого элемента.

###Анализ:

- Использует линейную интерполяцию для выбора точки разделения
- Эффективен для равномерно распределенных данных

###Временная сложность:

Лучший случай: O(log log n)
###Причина O(log log n): Для равномерно распределенных данных область поиска сокращается быстрее чем в 2 раза на каждом шаге.

###Ключевые переменные:

- pos - расчетная позиция на основе интерполяции
- low, high - границы области поиска

##11. Поиск Фибоначчи

###Определение:
Алгоритм поиска, использующий числа Фибоначчи для деления области поиска.

###Анализ:

- Основан на числах Фибоначчи
- Избегает деления, используя только сложение и вычитание
- Эффективен для больших массивов

###Временная сложность:

Лучший случай: O(1)
###Причина O(log n): Использует числа Фибоначчи для деления области поиска, что дает логарифмическую сложность.

###Ключевые переменные:

- fibM, fibM_minus1, fibM_minus2 - числа Фибоначчи для деления области
- offset - смещение для корректировки индексов
